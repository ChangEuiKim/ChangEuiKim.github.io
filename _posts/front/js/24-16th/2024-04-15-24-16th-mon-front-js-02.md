---
title: '[JavaScript] 자바스크립트 기본 이론 : 자바스크립트의 변수와 함수'
layout: single
categories:
  - Frontend
  - JavaScript
tags:
  - ASAC 5기
  - Frontend
  - JavaScript

date: 2024-04-16 17:00:00 +0900
last_modified_at: 2024-05-13 23:30:00 +0900
---

# ASAC 5기 - 자바스크립트 기본 이론 : 자바스크립트의 변수와 함수

# 서론

> 자바스크립트는 다양한 방식으로 변수와 함수를 선언하고 사용할 수 있는 유연한 언어입니다. 이 글에서는 자바스크립트의 변수와 함수에 대해 깊이 있게 다루며, 시니어 개발자들도 감탄할 만한 수준의 정보를 제공하겠습니다.

## 자바스크립트의 변수

| 키워드 | 재선언 가능 | 재할당 가능 | 호이스팅 | 스코프 |
| ------ | ----------- | ----------- | -------- | ------ |
| var    | O           | O           | O        | 함수   |
| let    | X           | O           | TDZ      | 블록   |
| const  | X           | X           | TDZ      | 블록   |

### 💡 var

> var는 ECMAScript 6 이전부터 사용된 자바스크립트의 변수 선언 키워드로 재선언과 재할당이 가능합니다.

- var 호이스팅: 변수 선언부가 최상단으로 끌어올려지는 호이스팅이 발생하며, 초기화는 호이스팅되지 않습니다. 선언부와 초기화가 분리되어 있어 초기화 이전에 변수를 참조하면 undefined가 반환됩니다.
- 함수 스코프: var 변수는 함수 스코프를 가지며, 함수 내에서 선언된 변수는 해당 함수 내에서만 유효합니다. 스코프 내에서 변수 선언을 찾을 수 없으면 스코프 체인을 따라 상위 스코프로 이동해 변수를 찾습니다.

### 💡 let, const

> let, const는 ECMAScript 6에서 도입된 블록 스코프를 가지는 변수 선언 키워드로 재선언이 불가능합니다.

- let은 재할당이 가능한 변수를 선언할 때 사용되며, const는 상수를 선언할 때 사용됩니다.
- TDZ(Temporal Dead Zone): let, const 모두 호이스팅이 발생하지만, 초기화 이전에 사용될 수 없기에 ReferenceError가 발생합니다. TDZ는 변수가 선언된 위치부터 초기화되기 전까지의 사용 불가능한 구간을 의미합니다.
- 블록 스코프: let, const는 블록 스코프를 가지며, 해당 블록 내에서만 유효합니다. 이는 가독성과 유지보수성을 높이는 데 도움을 줍니다.

### 💡 리터럴 Literal

> 리터럴은 코드에서 보이는 그대로의 값으로 변수에 할당될 수 있는 값입니다.

- 숫자 리터럴: 정수와 부동소수점 등 숫자를 표현합니다.
- 문자열 리터럴: 큰따옴표("), 작은따옴표('), 백틱(\`)으로 묶어 텍스트를 표현합니다.
- 불리언 리터럴: 참(true) 또는 거짓(false)의 논리값입니다.
- 객체 리터럴: 중괄호({})를 사용하여 키-값 쌍을 포함하는 객체를 표현합니다.
- 배열 리터럴: 대괄호([])를 사용하여 요소를 포함하는 배열을 표현합니다.
- 함수 리터럴: function 키워드를 사용하여 정의된 함수를 표현합니다.

## 자바스크립트의 함수

### 💡 자바스크립트 엔진

> 자바스크립트는 V8, SpiderMonkey, Chakra 등 다양한 엔진을 사용하여 코드를 실행합니다.

- **힙 Heap:**

  - Heap은 동적으로 생성된 객체를 저장하는 메모리 공간입니다.
  - var 변수의 Variable Environment와 let, const 변수의 Lexical Environment가 저장됩니다.
  - V8 엔진은 Heap을 사용하여 객체를 생성하고 관리합니다.

- **스택 Stack:**

  - Stack은 함수 호출을 관리하는 메모리 공간입니다.
  - 함수의 실행 환경인 실행 컨텍스트가 LILO(Last In, Last Out) 구조로 저장됩니다.
  - V8 엔진은 Stack을 사용하여 함수 호출을 추적하고 실행합니다.

### 💡 자바스크립트 함수의 구동 방식

> 자바스크립트의 함수는 함수 실행을 위한 시스템의 메모리 영역을 확보하고, 함수 실행이 끝나면 메모리를 해제하는 방식으로 동작합니다.

자바스크립트 파일을 실행하면 해당 파일의 전역 실행 컨텍스트가 생성되며, 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됩니다. 실행 컨텍스트는 변수, 함수, 객체 등을 저장하며, 함수가 실행되면 실행 컨텍스트가 스택에 쌓이고, 함수가 종료되면 스택에서 제거됩니다.

### 💡 생성 페이즈 Creation Phase

> 실행 컨텍스트의 생성 페이즈는 변수를 위한 메모리 공간을 할당하고, 변수 선언과 함수 선언을 스코프에 등록하는 과정입니다.

- var 변수는 undefined로 초기화되며, let과 const 변수는 초기화되지 않고 TDZ에 놓입니다.
- 자바스크립트의 코드가 실행 전에 엔진이 선언된 변수에 대해 알고있는 현상을 마치 변수 선언이 위로 끌어올려진 것처럼 보이기 때문에 호이스팅이라고 부릅니다.
- 함수 선언은 렉시컬 환경에 등록되며, 선언된 시점 Lexing 의 변수에 대한 참조를 가지고 있습니다.
- 이를 정적 스코프(lexical scoping)라고 하며, 함수가 정의된 위치에 따라 스코프를 결정합니다.
- 반대로 동적 스코프(dynamic scoping)는 함수가 호출된 위치에 따라 스코프를 결정하는 것을 말합니다.

### 💡 실행 페이즈 Execution Phase

> 실행 컨텍스트의 실행 페이즈는 실제 코드가 실행되며, 변수에 값이 할당되고 함수가 호출됩니다.

- var 변수에 값이 할당되며, 선언되지 않은 경우 상위 스코프에서 선언된 변수를 찾습니다.
- 현재 스코프에서 상위 스코프로 이동하며 전역 스코프까지 이동하는것을 스코프 체인이라고 합니다.
- let, const 변수는 선언된 시점에서 초기화됩니다.
- 선언되기 이전에 사용할 수 없는 구간을 TDZ(Temporal Dead Zone)라고 하며, 사용시 ReferenceError가 발생합니다.

### 💡 렉시컬 환경 Lexical Environment

> 렉시컬 환경은 함수가 호출될 때마다 생성되는, 변수와 함수 선언 정보를 담고 있는 객체입니다. 자바스크립트는 렉시컬 환경을 통해 변수의 유효 범위를 관리합니다.

렉시컬 환경은 두 가지 주요 구성 요소로 나뉩니다:

- 환경 레코드(Environment Record):

  - 현재 스코프에 있는 모든 변수와 함수 선언을 저장합니다.
  - 전역 환경 레코드(Global Environment Record): 전역 변수와 함수 선언을 저장합니다.
  - 함수 환경 레코드(Function Environment Record): 함수 내부의 변수와 함수 선언을 저장합니다.

- 외부 렉시컬 환경 참조(Outer Lexical Environment Reference):

  - 함수가 정의된 시점의 외부 스코프를 참조합니다. 이를 통해 스코프 체인이 형성됩니다.
  - 현재 실행 중인 함수의 렉시컬 환경에서 변수를 찾지 못하면, 외부 렉시컬 환경 참조를 따라 상위 스코프로 이동하며 변수를 탐색합니다.

### 💡 클로저 Closure

> 클로저는 렉시컬 환경을 기반으로 함수가 선언된 시점의 외부 스코프에 접근할 수 있는 함수입니다.

외부 함수가 내부 함수를 반환하고, 내부 함수가 외부 함수의 변수에 접근할 때 클로저가 생성됩니다. 외부 함수의 실행 컨텍스트가 스택에서 제거되어도 클로저는 외부 함수에서 선언된 변수에 접근할 수 있습니다.

```javascript
function outer() {
  var outerVar = 'I am outer variable';
  function inner() {
    var innerVar = 'I am inner variable';
    console.log(outerVar); // 'I am outer variable'
  }
  return inner;
}

var innerFunc = outer();
innerFunc();
```

1. outer 함수가 호출되면 outerVar 변수가 생성되고, inner 함수가 생성됩니다.
2. inner 함수가 outer 함수의 변수 outerVar에 접근할 수 있으며, outer 함수의 실행 컨텍스트가 스택에서 제거되어도 inner 함수는 outerVar 변수에 접근할 수 있습니다.
3. inner 함수가 반환되어 innerFunc 변수에 할당되고, innerFunc 함수가 호출되면 outerVar 변수를 참조할 수 있습니다.

## 결론

> 자바스크립트와 변수와 함수와 관련해서 자바스크립트 엔진의 구동방식과 렉시컬 환경에 대해 알아보았습니다. 변수와 함수를 잘 사용하기 위해서는 호이스팅과 스코프 체인의 동작 방식을 이해하는 것이 중요합니다.
