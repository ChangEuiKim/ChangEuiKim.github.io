---
title: '[ASAC 5기 OnePoint] 자바스크립트 기본, 심화 문법 및 엔진 동작 원리'
layout: single
categories:
  - ASAC
  - OnePoint
  - JavaScript
  - Programming Paradigm
  - First Class Function
  - Pure Function
  - Side-Effects
  - Shallow Copy
  - Deep Copy
  - var
  - let
  - const
  - Function Scope
  - Block Scope
  - Var Hoisting
  - Literal
  - Function Declaration
  - Function Expression
  - Arrow Function
  - This Binding
  - Creation Phase
  - Execution Phase
  - Execution Context
  - Lexical Environment
  - Scope Chain
  - Hoisting
  - Closure
  - Object
  - Method
  - Class
  - Encapsulation
  - Getter
  - Setter
  - Inheritance
  - Prototype
  - Module
  - ESM
  - CJS
  - Callback Function
  - Promise
  - async/await
  - Object Destructure
  - Property Initializer Shorthand
  - Computed Property Name
  - Array Destructure
  - Trailing Comma
  - Spread Syntax
  - Rest Parameters
  - Default Parameters
  - Currying
  - Literal Template
  - Map
  - Set
  - loop
  - truthy
  - falsy
  - Ternary Operator
  - Short-Circuit Evaluation
  - Nullish Coalescing Operator
  - Optional Chaining
  - Non-Null Assertion Operator
tags:
  - ASAC 5기
  - OnePoint
  - JavaScript

date: 2024-05-03 23:00:00 +0900
last_modified_at: 2024-05-03 23:00:00 +0900
---

# ASAC 5기 One Point - 자바스크립트 기본 이론 1 : 01-01. 자바스크립트 기본, 심화 문법 및 엔진 동작 원리

## 1 함수형 프로그래밍 패러다임

### 💡 프로그래밍 패러다임은 무엇인가?

프로그래밍 패러다임은 프로그래밍 언어의 스타일을 말합니다. 프로그래밍 패러다임은 프로그래밍 언어의 문법과 구조를 결정하며, 프로그래밍 언어의 사용 방법을 제안합니다. 프로그래밍 패러다임에는 명령형 프로그래밍, 선언형 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍 등이 있습니다. 자바스크립트는 다중 패러다임 언어로, 명령형 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍을 모두 지원합니다.

### 💡 일급 함수 First Class Function 는 무엇인가?

일급 함수는 함수를 값처럼 다룰 수 있는 프로그래밍 언어의 특성을 말합니다. 일급 함수를 지원하는 언어는 함수를 변수에 할당하거나, 함수를 매개변수로 전달하거나, 함수를 반환할 수 있습니다. 자바스크립트는 일급 함수를 지원하는 언어이며 함수를 값처럼 다룰 수 있습니다.

### 💡 순수 함수 Pure Function 는 왜 중요한가?

순수 함수는 부작용이 없는 No Side-Effects 함수를 말합니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며, 외부 상태를 변경하지 않는 참조 투명성 Referentially Transparent 을 갖습니다. 순수 함수는 부작용이 없기 때문에 테스트하기 쉽고, 멀티 스레드 환경에서 병렬 작업을 안전하게 Thread-Safe 처리할 수 있습니다. 순수 함수는 함수형 프로그래밍의 핵심 개념 중 하나입니다.

### 💡 부작용 Side-Effects 은 무엇이며 해결 방법은?

부작용은 함수의 외부 상태를 변경하는 것을 말합니다. 부작용은 함수의 동작을 예측하기 어렵게 만들며, 코드의 가독성을 떨어뜨리고, 디버깅을 어렵게 만듭니다. 부작용을 해결하기 위해 순수 함수를 사용하거나, 불변 객체 Immutable Object 를 사용하거나, 상태 관리 라이브러리를 사용하는 방법이 있습니다.

### 💡 얕은 복사 Shallow Copy 와 깊은 복사 Deep Copy 의 차이점은?

얕은 복사는 객체의 참조만 복사하는 방식으로 1계층까지 복사하여, 객체의 내부 객체는 참조가 공유됩니다. 깊은 복사는 객체의 내부 객체까지 모두 복사하는 방식으로, 객체의 내부 객체도 새로운 객체로 생성됩니다. 얕은 복사는 Object.assign() 메소드나 전개 연산자 Spread Operator 를 사용하여 수행할 수 있으며, 깊은 복사는 직렬화 Serialization 와 역직렬화 Deserialization 을 사용하여 수행할 수 있습니다.

## 2 자바스크립트의 변수

### 💡자바스크립트의 변수 Variable 는 어떻게 선언하고 사용하는가?

자바스크립트의 변수는 var, let, const 키워드로 선언할 수 있습니다. var 키워드는 함수 스코프 Function Scope 를 가지며, let, const 키워드는 블록 스코프 Block Scope 를 가집니다. var 키워드는 재선언이 가능하며, let, const 키워드는 재선언이 불가능합니다. var, let 키워드는 재할당이 가능하며, const 키워드는 재할당이 불가능합니다.

### 💡 함수 스코프 Function Scope와 블록 스코프 Block Scope는 무엇이 다른가?

함수 스코프는 함수 내부에서 선언된 변수가 함수 내부에서만 유효한 스코프를 말합니다. 블록 스코프는 블록 내부에서 선언된 변수가 블록 내부에서만 유효한 스코프를 말합니다. 함수가 선언되는 시점에 실행 컨텍스트 Execution Context 가 생성되며, 함수 스코프는 실행 컨텍스트의 변수 환경 Lexical Environment 에 저장됩니다. 블록이 실행되는 시점에 블록 스코프가 생성되며, 블록 스코프는 블록 내부의 중괄호 {} 에 의해 결정됩니다.

### 💡 변수 호이스팅 Var Hoisting 은 무엇인가?

변수 호이스팅은 변수 선언이 스코프의 최상단으로 끌어올려지는 현상을 말합니다. var 키워드로 선언된 변수는 선언 단계에서 초기화 단계가 분리되어, 선언 단계에서 변수가 스코프의 최상단으로 끌어올려지고, 초기화 단계에서 변수에 undefined 값이 할당됩니다. let, const 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어, 선언 단계에서 변수가 스코프의 최상단으로 끌어올려지지만, 초기화 단계에서 변수에 undefined 값이 할당되지 않습니다.

### 💡 리터릴 Literal은 무엇인가?

리터럴은 변수에 할당되는 고정된 값 자체를 말합니다. 리터럴은 숫자, 문자열, 불리언, 객체, 배열, 함수 등의 값으로 표현될 수 있습니다. 리터럴은 변수에 할당되는 값 자체이기 때문에, 변수에 할당된 값이 변경되어도 리터럴 값은 변하지 않습니다.

## 3 자바스크립트의 함수 정의 및 사용

### 💡 함수 선언식 Function Declaration 은 무엇인가?

자바스크립트의 함수는 function 키워드로 선언할 수 있습니다. 함수는 매개변수를 가질 수 있으며, 함수 내부에서 매개변수를 사용하여 연산을 수행할 수 있습니다. 함수는 return 키워드를 사용하여 결과값을 반환할 수 있으며, 반환값이 없는 경우에는 undefined 값을 반환합니다. 함수 선언식은 함수 이름을 사용하여 함수를 호출할 수 있으며, 함수 선언식은 호이스팅에 의해 함수 선언이 최상단으로 끌어올려지는 특성을 가집니다.

### 💡 함수 표현식 Function Expression 은 무엇이 다른가?

함수 표현식은 변수에 함수를 할당하는 방식으로 함수를 선언하는 방법을 말합니다. 함수 표현식은 함수를 익명 함수로 선언할 수 있으며, 변수에 할당된 함수를 호출할 때는 변수 이름을 사용하여 호출할 수 있습니다. 함수 표현식은 변수 호이스팅이 적용되기에, 함수는 변수가 선언된 위치에서부터 사용할 수 있습니다.

### 💡 화살표 함수 Arrow Function 는 무엇이 다른가?

화살표 함수는 ES6에서 도입된 함수 선언 방식으로, function 키워드 대신 => 화살표 연산자를 사용하여 함수를 선언하는 방법을 말합니다. 화살표 함수는 함수 내부에서 return 키워드를 사용하지 않아도 암묵적으로 반환값을 반환합니다. 화살표 함수는 함수 내부에서 this 바인딩을 동적으로 처리하지 않기에, 함수가 선언된 시점의 this를 참조합니다.

### 💡 함수의 사용과 this 바인딩

함수는 this 바인딩을 사용하여 함수 내부에서 this 키워드를 사용할 수 있습니다. this 바인딩은 동적 스코프를 사용하여 함수를 호출한 객체에 바인딩되며, 객체가 없는 경우에는 전역 객체에 바인딩됩니다. 명시적으로 this 바인딩을 설정하려면 call(), apply(), bind() 메소드를 사용할 수 있습니다. 화살표 함수는 정적 스코프를 사용하여 Scope Chain 을 따라 상위 스코프의 this 바인딩을 그대로 사용합니다.

### 💡 함수의 매개변수와 반환값

자바스크립트의 함수는 매개변수를 인자 형태 또는 객체 형태로 전달할 수 있습니다. 인자 형태로 전달시 순서대로 모든 매개변수를 전달해야하며, 객체 형태로 전달시 순서에 상관없이 원하는 매개변수만 전달할 수 있습니다. 자바스크립트의 함수는 반환값을 객체 형태 또는 배열 형태로 반환할 수 있습니다. 배열 형태로 반환시 순서대로 모든 반환값을 반환하며, 객체 형태로 반환시 순서에 상관없이 객체 비구조화 할당을 사용하여 반환값을 추출할 수 있습니다.

## 4 자바스크립트의 함수 실행 원리

### 💡 자바스크립트 엔진의 실행 원리

자바스크립트 엔진은 생성 단계 Creation Phase 와 실행 단계 Execution Phase 를 거쳐 구동됩니다. 생성 단계에서는 자바스크립트 파일을 분석하여 변수 선언과 함수 선언 정보를 활용하여 실행 컨텍스트 Execution Context 를 생성하고 Call Stack 메모리에 적재합니다. 실행 단계에서는 선언된 변수에 값을 할당해 초기화하고, 함수 선언지로부터 연결된 메모리 영역을 확보 후 그 안에서 함수를 실행합니다.

### 💡 실행 컨텍스트 Execution Context 은 무엇인가?

실행 컨텍스트는 자바스크립트 엔진이 코드를 실행하기 위해 필요한 정보를 담고 있는 객체를 말합니다. 함수가 호출되면 실행 컨텍스트가 생성되어 Call Stack에 적재되며, 함수가 종료되면 Call Stack에서 실행 컨텍스트가 제거됩니다. 실행 컨텍스트는 함수가 선언된 시점의 렉시컬 환경 Lexical Environment, 변수 환경 Environment Record, this 바인딩 This Binding 을 가지고 있습니다.

### 💡 렉시컬 환경 Lexical Environment 과 스코프 체인 Scope Chain

렉시컬 환경은 변수와 함수의 식별자를 저장하는 환경을 말합니다. 렉시컬 환경은 환경 레코드 Environment Record 와 외부 렉시컬 환경에 대한 참조 Outer Lexical Environment Reference 를 가지고 있습니다. 스코프 체인은 렉시컬 환경의 외부 렉시컬 환경에 대한 참조를 순차적으로 연결한 체인을 말합니다. 선언되지 않은 변수를 참조할 때, 현재 렉시컬 환경에서 외부 렉시컬 환경으로 순차적으로 탐색하여 변수를 찾습니다. 이를 렉시컬 스코프 Lexical Scope를 사용한 스코프 체인 Scope Chain 탐색이라고 합니다.

### 💡 렉시컬 스코프 Lexical Scope 와 호이스팅 Hoisting

렉시컬 환경은 변수 선언과 함수 선언을 실행 컨텍스트 내부에 저장하는 환경을 말합니다. 호이스팅은 변수 선언과 함수 선언이 실행 컨텍스트의 최상단으로 끌어올려지는 현상을 말합니다. 호이스팅은 변수 선언과 함수 선언이 렉시컬 환경에 저장되어있기에 변수 선언과 함수 선언이 실행 코드보다 먼저 실행되는 것처럼 보이는 현상입니다.

### 💡 렉시컬 스코프 Lexical Scope 와 클로저 Closure

클로저는 함수가 선언된 렉시컬 환경을 기억하여 외부 렉시컬 환경에 대한 참조를 유지하는 현상을 말합니다. 실행 컨텍스트가 종료되어도 클로저가 참조하는 외부 렉시컬 환경은 가비지 컬렉터에 의해 제거되지 않아 그대로 참조할 수 있습니다. 이는 의도된 상태이기에 메모리 누수 Memory Leak 가 아니지만, 실수로 클로저로 생성된 함수는 반드시 nullify를 해야합니다.

## 5 자바스크립트의 객체 Object 와 클래스 Class

### 💡 객체 Object 의 생성과 사용

객체는 필드 Field 와 메소드 Method 를 프로퍼티 Property 로 갖는 데이터 구조를 말합니다. 자바스크립트의 객체는 중괄호 {} 내에 키:값 형태로 프로퍼티를 사용하는 객체 리터럴 방식으로 선언할 수 있습니다. 또는 new 키워드를 사용하여 생성자 함수 Constructor Function 로 객체를 생성할 수 있습니다. 객체의 프로퍼티는 점 표기법 Dot Notation 또는 대괄호 표기법 Bracket Notation 을 사용하여 접근할 수 있습니다.

### 💡 메서드 Method 는 무엇인가?

메소드는 객체의 동작을 정의하는 함수로, 객체의 상태를 변경하거나 객체의 정보를 반환하는 역할을 합니다. 자바스크립트의 메서드는 객체의 프로퍼티로서 호출된 함수를 말합니다. 메서드는 객체의 프로퍼티에 함수를 할당하거나, 메서드 표현법을 사용하여 객체에 메서드를 추가할 수 있습니다.

### 💡 클래스 Class 와 캡슐화 Encapsulation

클래스는 역할과 책임에 따라 객체의 필드와 메소드를 정의하는 틀입니다. 자바스크립트의 클래스는 class 키워드를 사용하여 선언할 수 있으며, constructor() 메소드를 사용하여 객체의 초기화를 수행할 수 있습니다. 클래스는 new 키워드를 사용하여 객체를 생성할 수 있으며, extends 키워드를 사용하여 상속을 구현할 수 있습니다.

### 💡 클래스의 정보 은닉과 getter, setter

정보 은닉은 객체의 상태를 외부에서 직접 접근하지 못하도록 보호하는 기법을 말합니다. 필드는 최대한 숨기고 메서드는 최소한으로 노출하기 위해 `#` 키워드를 사용해 프로퍼티를 private로 선언하고, 필요한 부분에만 getter, setter 메서드를 사용하여 외부에서 필드에 접근할 수 있도록 합니다.

### 💡 클래스의 상속 Inheritance 과 프로토타입 Prototype

자바스크립트는 프로토타입 기반의 언어입니다. new 키워드와 생성자 함수를 사용하면, 생성자 함수의 prototype 프로퍼티를 참조하는 `__proto__` 프로퍼티를 가진 객체가 생성됩니다. 자바스크립트는 이러한 프로토타입 체인 Prototype Chain 을 사용하여 상속을 구현합니다. ES6에 도입된 클래스 문법은 프로토타입 기반의 상속을 클래스 기반의 상속처럼 사용할 수 있도록 구현한 문법적 설탕입니다.

## 4 자바스크립트의 모듈 Module

### 💡 HTML `<script>` 태그

초기에는 HTML 내에 `<script>` 태그를 사용하여 자바스크립트 파일을 로드하였습니다. 이는 성능 최적화의 한계, 전역 스코프 오염, 스크립트 로딩 순서, 코드 재사용의 어려움 등의 문제가 있었습니다. 이러한 문제를 해결하기 위해 별도의 파일에 자바스크립트 코드를 작성하고, 외부에서 로드하여 사용할 수 있는 모듈 시스템이 개발되었습니다.

### 💡 ECMAScript Module의 사용방법

ECMAScript Module은 ES6에서 도입된 모듈 시스템으로, export 키워드와 import 키워드를 사용하여 모듈을 정의하고 사용할 수 있습니다. export 키워드는 모듈에서 외부로 내보낼 변수, 함수, 클래스를 정의하며, import 키워드는 외부 모듈에서 내보낸 변수, 함수, 클래스를 가져와 사용할 수 있습니다. 단일 항목을 내보낼 경우 export default 키워드를 사용하여 내보낼 수 있습니다.

### 💡 CommonJS Module의 사용방법

CommonJS Module은 Node.js에서 사용되는 모듈 시스템으로, module.exports 객체와 require 함수를 사용하여 모듈을 정의하고 사용할 수 있습니다. module.exports 객체는 모듈에서 외부로 내보낼 변수, 함수, 클래스를 정의하며, require 함수는 외부 모듈에서 내보낸 변수, 함수, 클래스를 가져와 사용할 수 있습니다.

### 💡 ESM 방식과 CJS 방식의 선택 기준

ES6 이후로 ESM 모듈이 표준으로 사용되고 있습니다. Node.js에서도 ESM 모듈을 사용할 수 있지만, 아직까지 CommonJS 모듈이 많이 사용되고 있습니다. ESM 모듈은 정적 모듈 시스템으로, 모듈을 미리 로드하기 때문에 빌드 타임에 Tree-Shaking이 가능합니다. CJS 모듈은 동적 모듈 시스템으로, 런 타임에 모듈을 로드하기 때문에 빌드 타임에 정적 분석이 어렵습니다.

## 5 자바스크립트의 비동기 작업의 동기적 처리

### 💡 콜백 함수 Callback Function 의 비동기 처리

콜백 함수는 일급 함수를 파라미터로 넘겨 함수의 실행권을 다른 함수에 넘기는 기법을 말합니다. 주로 비동기 처리에 동기적 흐름을 부여하기 위해 사용되며, 비동기 함수의 실행이 완료되면 콜백 함수를 호출하여 결과값을 반환합니다. 콜백 지옥 Callback Hell 은 콜백 함수를 중첩하여 사용할 때 발생하는 가독성이 떨어지는 문제를 말합니다.

### 💡 프로미스 Promise 객체의 비동기 처리

프로미스는 비동기 처리를 위해 ES6에서 도입된 객체로, 비동기 작업을 처리하는 Caller 역할과 처리 후 콜백을 실행하는 Callee 역할을 모두 수행합니다. 객체 생성시 Pending 상태로 시작하여, 비동기 작업이 완료되면 Fulfilled 상태로 전환되어 resolve 콜백을 반환하며, 비동기 작업이 실패하면 Rejected 상태로 전환되어 reject 콜백을 반환합니다. 객체에 then() 메서드를 호출시 성공 콜백이 주입되며, catch() 메서드를 호출시 실패 콜백이 주입됩니다. 프로미스 체인 Promise Chain 을 사용하여 프로미스 지옥 Promise Hell 을 해결할 수 있습니다.

### 💡 async/await 의 비동기 처리

async/await는 ES8에서 도입된 비동기 처리 방식으로, 프로미스를 기반으로 동작합니다. async 키워드가 붙은 함수는 반환값이 Promise가 아닌것도 Promise를 감싸서 반환합니다. 에러 발생시 try/catch 문으로 감싸서 예외를 처리해야 합니다. await 키워드는 async 함수 내부에서만 사용할 수 있으며, Promise 객체가 이행되기를 기다렸다가 결과값을 반환합니다.

### 💡 Callback 기반 비동기 처리

Callback 기반 비동기 처리는 대표적으로 ajax와 jQuery ajax가 있습니다. ajax는 브라우저별로 XMLHttpRequest 구현체가 다르고 CSRF 를 직접 처리해야하는 문제가 있습니다. jQuery ajax는 크로스 브라우징을 지원하고 CSRF 토큰을 자동으로 처리해주지만, jQuery 라이브러리의 용량이 크고, 라이브러리 의존성이 높아질 수 있습니다.

### 💡 Promise 기반 비동기 처리

Promise 기반 비동기 처리는 대표적으로 Fetch API와 Axios가 있습니다. Fetch API는 브라우저에서 제공하는 네이티브 API로 가벼운 장점이 있지만, 직렬화 역직렬화를 직접 처리해야하고, 오래된 브라우저에서는 지원하지 않는 문제가 있습니다. Axios는 HTTP 클라이언트 라이브러리로 브라우저와 Node.js 환경에서 사용할 수 있으며, 직렬화 역직렬화를 자동으로 처리해주고 오류 처리가 용이한 장점이 있습니다.

## 6 자바스크립트의 ES6+ 문법

### 💡 객체와 배열

- 객체 비구조화 Object Destructure
  - 객체의 프로퍼티를 추출하여 변수에 할당할 수 있습니다. 리액트 this.props 할당 등에 자주 사용합니다.
- 객체 프로퍼티 단축 Property Initializer Shorthand
  - 객체의 프로퍼티 이름과 변수 이름이 동일한 경우, 프로퍼티 이름을 생략할 수 있습니다.
- 계산된 프로퍼티 이름 Computed Property Name
  - 객체의 프로퍼티 이름을 대괄호 []로 감싸면, 변수의 값으로 프로퍼티 이름을 동적으로 생성할 수 있습니다.
- 배열 비구조화 Array Destructure
  - 배열의 요소를 추출하여 변수에 할당할 수 있습니다.
- 얕은 복사 Shallow Copy
  - React에서 설정자 함수에 새로운 상태를 할당할 때 얕은 복사를 수행하여 새로운 객체를 할당합니다.
- 마지막 콤마 Trailing Comma
  - 배열과 객체의 마지막 요소 뒤에 콤마를 추가해 변경사항을 추적하기 쉽게 만듭니다.
- 특정 요소 포함 여부 확인 Includes
  - 배열에 특정 요소가 포함되어 있는지 확인할 수 있습니다.

### 💡 함수

- 펼치기 문법 Spread Syntax
  - 배열이나 객체의 요소를 `...rest`를 사용해 펼쳐서 새로운 배열이나 객체로 만들 수 있습니다.
- 나머지 매개변수 Rest Parameters
  - 함수의 매개변수를 `...rest`를 사용해 새로운 배열로 받아 사용할 수 있습니다.
- 함수 기본 파리미터 Default Parameters
  - 함수의 매개변수에 기본값을 설정할 수 있습니다.
- 커링 Currying
  - 함수를 호출할 때 매개변수를 하나씩 받아서 새로운 함수를 반환하는 기법을 말합니다.

### 💡 자료구조

- 리터럴 템플릿 Literal Template
  - 문자열을 백틱 ``으로 감싸면, 템플릿 리터럴을 사용할 수 있습니다.
- Map 자료구조
  - 키와 값으로 이루어진 컬렉션을 생성하고, 키를 사용하여 값을 조회할 수 있습니다.
- Set 자료구조
  - 중복되지 않는 요소로 이루어진 컬렉션을 생성하고, 요소를 추가하거나 삭제할 수 있습니다.

### 💡 반복문

- for ... of
  - 배열, 문자열, Map, Set, arguments 객체 등의 요소를 반복할 수 있습니다.
- forEach
  - 배열의 요소를 반복하며, 요소를 인자로 받아 콜백 함수를 실행할 수 있습니다.
- for ... in
  - 객체의 프로퍼티를 반복할 수 있습니다.

### 💡 조건문

- truthy 값
  - true, 1, 'string', [], {} 값은 truthy 값으로 평가됩니다.
- falsy 값
  - false, 0, '', null, undefined, NaN 값은 falsy 값으로 평가됩니다.
- 삼항 연산자 Ternary Operator
  - 조건식 ? 참일 때 값 : 거짓일 때 값 을 사용하여 조건문을 간결하게 표현할 수 있습니다.
- 단축 평가 Short Circuit Evaluation

  - 논리 연산자를 사용하여 표현식을 평가할 때, 첫 번째 피연산자만으로 결과를 결정할 수 있습니다.
  - 논리 OR 연산자 `||` 는 첫 번째 피연산자가 truthy 값이면 두 번째 피연산자를 평가하지 않습니다.
  - 논리 AND 연산자 `&&` 는 첫 번째 피연산자가 falsy 값이면 두 번째 피연산자를 평가하지 않습니다.

### 💡 널 가딩 Null Guarding

- 널 병합 연산자 Nullish Coalescing Operator
  - null 또는 undefined 값을 처리할 때 `??` 연산자를 사용하여 기본값을 설정할 수 있습니다.
- 옵셔널 체이닝 Optional Chaining
  - null 또는 undefined 일 수 있는 객체의 중첩된 프로퍼티를 `?.` 연산자를 사용하여 안전하게 접근할 수 있습니다.
- Non-Null Assertion Operator
  - 절대 null 또는 undefined 일 수 없는 값을 `!` 연산자를 사용하여 단언할 수 있습니다.
