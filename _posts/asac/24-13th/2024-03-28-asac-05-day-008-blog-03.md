---
title: "[JavaScript] 모듈 Module"
layout: single
tags:
  - ASAC 5기
  - Frontend
  - JavaScript
  - Syntax
categories:
  - JavaScript
date: 2024-03-29 14:18:00 +0900
last_modified_at: 2024-03-29 14:18:00 +0900
---

# 모듈 Module

- 모듈은 중복되는 코드의 사용을 방지하고 효율적으로 작업하기 위해 재사용 가능한 코드 조각을 모아 별도의 파일로 분리한 것을 말한다.
- 소스 코드를 별도의 파일로 분리하면 스코프 관리와 네임스페이스 충돌 방지 등 여러가지 측면에서 생산성을 향상시킬 수 있다.

## 라이브러리 Library

- 모듈을 모아둔 코드의 모음이다.
- 개발자는 라이브러리에서 원하는 기능을 찾아 해당 기능을 import하여 코드를 재사용한다.
- 프레임워크와 다른 점은 코드 사용의 제어권이 개발자에게 있다는 점이다. 개발자가 직접 컨트롤하기에 세밀한 조정이 가능하지만, 코드가 복잡해지고 휴먼 에러의 위험성을 배제할 수 없다.

## 프레임워크 Framework

- 모듈을 모아둔 코드의 모음이 정해진 규칙에 따라 기능하는 것이다.
- 개발자는 정해진 틀에 따라 소스 코드를 작성하면 프레임워크가 미리 약속된 규칙에 따라 필요한 기능을 모듈에서 불러와 전체 기능을 완성한다.
- 라이브러리와 다른 점은 코드 사용의 제어권이 프레임워크에 있다는 점이다. 개발자는 많은 부분을 프레임워크에 위임하고 필요한 부분만 소스 코드를 작성해 휴먼 에러의 위험성을 줄이고 생산성을 향상시킬 수 있다. 이를 제어의 역전 IoC라고 부른다.

### 트리 쉐이킹 Tree Shaking

- 라이브러리나 프레임워크는 많은 모듈을 가지고 있기 때문에 모든 모듈을 가져와서 쓸 경우 성능상의 문제가 생길 수 있다.
- 이를 해결하기 위해 빌드 도구는 코드를 실행하기 전에 어떤 모듈의 어떤 기능이 사용되는지를 미리 파악하고 사용되지 않는 코드를 제외한 채로 코드를 실행한다. 이를 나무를 털어내는것과 같다고 하여 트리 쉐이킹이라고 한다. 주로 정적 모듈에서 효과적으로 작동한다.

## CommonJS (CJS)

- 동적 구조와 분석의 어려움
    - CJS는 런타임에 모듈을 로드하고 해석한다. require() 함수가 조건문 내부나 실행 흐름 어디에서도 호출될 수 있기 때문에 모듈의 의존성이 동적으로 변화될 수 있다.
    - 이로 인해 빌드 도구는 CJS 모듈의 의존성을 정적으로 분석하기 어렵게 된다. 어떤 코드가 사용되고 어떤 코드가 사용되지 않는지 실행 전에는 알기 어렵기 때문에 트리 쉐이킹이 효과적으로 작동하지 않는다.
- 특징
    - 전통적으로 모듈을 생성하고 사용하는데 작성한 방식이다.
    - 많은 라이브러리가 CJS 방식으로 구현되어 있으며, 특히 백엔드 쪽에서 주로 채택된 방식이다.
- module.exports에 객체를 담아서 외부 스코프에서 모듈에 접근할 때 노출할 객체를 지정한다.
    - 
        ```jsx
        // module.js
        const add = (x, y) => x + y;

        module.exports = {
            add,
        };
        ```
      
- require() 함수를 사용해 외부 스코프에서 모듈에 접근 가능한 객체를 가져온다.
    -     
        ```jsx
        // App.js
        const module = require('./module');
        
        module.add(1 + 2);
        ```
    

## ES Module (ESM)

- 정적 구조와 분석의 용이성
    - import 선언은 파일의 최상위에서만 사용될 수 있고, 컴파일 시점에서 모든 의존성이 명확하다.
    - 이로 인해 빌드 도구는 ESM 모듈의 의존성을 정적으로 분석하고 사용되는 코드와 사용되지 않는 코드를 정확하고 빠르게 식별 가능하다. 따라서 트리 쉐이킹이 효과적으로 작동한다.
- 특징
    - 프론트 엔드 영역에서 표준화되었고 node.js 12부터 공식 채택된 방식이다.
    - 최적화를 위한 여러 기법을 적용할 수 있다.
    - ESM의 경우 import()를 사용한 동적 임포트를 통해 코드 분할을 수행애 애플리케이션의 성능을 끌어올릴 수 있다. 빌드 도구가 애플리케이션을 여러 개의 작은 청크로 나누어 코드를 분할하고, 모듈이 필요한 순간에만 로드해 사용자의 초기 인터랙션 시간을 크게 줄일 수 있다.
- export 키워드를 사용해 모듈에서 외부 스코프에 노출시킬 대상을 지정한다. (named export)
    -    
        ```jsx
        // module.js
        export const add = (x, y) => x + y;
        ```
    
- 단일 대상을 내보낸다면 default 키워드를 사용할 수 있다. (default export)
    -    
        ```jsx
        // module.js
        const add = (x, y) => x + y;
        export default add;
        ```
    
- import … from을 최상단에 사용해 외부 스코프에서 모듈에 접근 가능한 객체를 가져온다.
    -   
        ```jsx
        // App.js
        import module from './module.js';
        
        module.add(1 + 2);
        ```